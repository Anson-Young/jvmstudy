1、在Java代码中，类型(Class、Interface、Enum)的加载、连接、初始化过程都是在程序运行期间完成的。
	其中连接又分为验证、准备、解析三个阶段。解析阶段是将符号引用转化为直接引用。
	符号引用与直接引用
	例1：
	public interface Intf {    
	    public static String str = "abcde";
	    public static int ival = new Random().nextInt();
	}
	public class T {
	    public static int tint = Intf.ival;
	}
	T类中静态变量tint的值在编译期间不确定，只能在运行期间确定，因此在编译期间先用符号引用指向Intf的ival字段，等运行的时候再将符号引用解析为直接引用。
	例2：
	public static void main(String[] args) {
		new ArrayList<>();
	}
	ArrayList在类生命周期的解析阶段之前，这就只是个符号，即符号引用。在解析过程中，JVM会去找ArrayList是否被加载，如果未加载会先加载ArrayList，然后返回ArrayList的引用，这就是直接引用。
	
2、类的主动使用与被动使用。
	类在被动使用时不会被初始化！只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用
	例：
	public class MyTest {
		public static void main(String[] args) {
			System.out.println(Child.str);	// parent static block
																// hello world
		}
	}
	
	class Parent {
		public static String str = "hello world";
		
		static {
			System.out.println("parent static block");
		}
	}
	
	class Child extends Parent {
		static {
			System.out.println("child static block");
		}
	}
	原因：Child类为被动使用，虽然是用Child访问的str字段。对于静态字段来说，只有直接定义了该字段的类才会被初始化。(但是Child类会被加载)
	
3、可以在编译期确定值的常量称为编译期常量，在编译阶段会存入到调用这个常量的方法所在类的常量池中。本质上，调用类并没有直接引用到定义该常量的类，因此并不会触发定义常量的类的初始化，甚至这个类都没有被加载，可以将定义该常量的类的class文件删除。
	例：
	public class MyTest {
		public static void main(String[] args) {
			System.out.println(MyParent.str);	// hello world(MyParent里的静态代码块不会被执行)
		}
	}
	
	class MyParent {
		public static final String str = "hello world";
		
		static {
			System.out.println("MyParent static block");
		}
	}
4、初始化一个类的子类，会先初始化它的父类，但是不会初始化它实现的接口；
   初始化一个接口，也并不会初始化它继承的父接口。
   但是两种情况无论是继承父类、父接口还是实现的接口都会被加载(注意加载和初始化是两个概念)，
   如果将实现的接口或继承的父接口的字节码删除，再运行会报NoClassDefFoundError(编译正常，运行时找不到这个类)
   例：
   	public class MyTest {
		public static void main(String[] args) {
			System.out.println(MyChild.i);
			// MyParent
			// a random number
			System.out.println(AnotherInterface.a);	// a random number
		}
	}

	interface MyInterface {
		Object o = new Object() {
			{
				System.out.println("MyInterface");
			}
		};	
	}

	class MyParent {
		static {
			System.out.println("MyParent");
		}
	}

	class MyChild extends MyParent implements MyInterface {
		public static final int i = new Random().nextInt(100);
	}

	interface AnotherInterface extends MyInterface {
		int a = (int) (Math.random() * 100);
	}
   
5、类在加载之后的连接准备阶段会为类的静态变量(final常量除外)赋默认值，在初始化阶段才会按顺序为类的静态变量执行初始化语句。
   例：
   	public class MyTest {
		public static void main(String[] args) {
			Singleton singleton = Singleton.getInstance();
			System.out.println(Singleton.a);	// 1
			System.out.println(Singleton.b);	// 0
		}
	}

	class Singleton {
		public static int a;

		private static Singleton singleton = new Singleton();

		private Singleton() {
			a++;
			b++;
			System.out.println(a);	// 1
			System.out.println(b);	// 1
		}

		public static int b = 0;


		public static Singleton getInstance() {
			return singleton;
		}
	}
6、可以通过虚拟机参数-XX:+TraceClassLoading来观察有哪些类被加载
7、加载只是类加载的其中一个阶段，类加载的全过程包括加载、连接(验证、准备、解析)、初始化这几个阶段。
   加载阶段最终会在虚拟机内存中生成代表这个类的Class对象。
8、ClassNotFoundException与NoClassDefFoundError区别：
   ClassNotFoundException间接继承自Exception，为受检异常，程序当中可以捕获，抛出此异常的常见场景是
   Class.forName("xxx.yyy.zzz.className");在运行期找不到需要加载的类，其本质是在类加载的加载阶段找不到此类而无法生成对应的Class对象。
   NoClassDefFoundError继承自LinkageError，通过名字可以看出是在类加载的连接阶段发生的错误。具体发生在连接阶段所包含的3个阶段中的最后一个阶段——解析阶段，如果在解析阶段找不到相应的类就会报NoClassDefFoundError。例如上面4的叙述内容，程序正常编译后删除所实现或继承接口的class文件，然后在运行时先进入子类加载的加载阶段，在加载的过程中进行解析，解析过程中要将所实现或继承接口的符号引用替换为直接引用，在替换时发现找不到所实现或继承的接口，就会报NoClassDefFoundError。注意：加载阶段与连接阶段是按照先后顺序开始，并不是按照先后顺序进行或完成，这两个阶段是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。
   参考链接：https://blog.csdn.net/qq_36781505/article/details/89053304
9、
